\chapter{Base Algorithms}
The algorithms that I investigated for this thesis can be grouped very broadly into two approaches, which I will describe in the following two sections.

\section{Enumeration algorithms}
\subsection{Model Enumeration}
A simple definition of the backbone is that it is the intersection of all models of it's formula. If a literal is not part of the backbone, there must exist a model that contains the negation of that literal. Therefore if we had a way to iterate over every single model of the formula and, starting with the set of both literals for every variable and removing every literal from that set that was missing in one of these models, that set would end up being the backbone of the formula. \cite{mjl10} as well as \cite{mjl15} list an algorithm that does exactly this. 

\begin{algorithm} %ueber alle models iterieren
\caption{{\sc Enumeration-based backbone computation}}
\DontPrintSemicolon
\KwIn{Satisfiable formula $F$}
\KwOut{Backbone of $F$, $\nu_r$}
$\nu_r \gets \{ x | x \in Var(F) \} \cup \{ \neg x | x \in Var(F) \}$\;
\While{$\nu_r \neq \emptyset$}{
	$(outc,\nu) \gets SAT(F)$\;
	\If{$outc = \bot$}{
		$return \; \nu_r$
	}
	$\nu_r \gets \nu_r \cap \nu$\;
	$\omega_B \gets \bigvee_{l \in \nu}\neg l$\;
	$F \gets F \cup \omega_B$\;
}
$assert(\nu_r = \emptyset)$\;
$\Return\; \nu_r$\;
\end{algorithm}

Here, found models are prevented from being found again by adding a blocking clause of said model and the algorithm terminates once all models are prohibited and the formula became unsatisfiable through this.

\subsection{Upper Bound Reduction}

Clearly, calculating every single model of a formula leaves room for optimization. Most models of a common boolean formula differ by small, independent differences that can just as well occur in other models. Therefore the intersection of only a handful of models can suffice to result in the backbone, as long as these models are chosen to be as different as possible. This was achieved in \cite{mjl15} as is described in algorithm 2.

\begin{algorithm}
\caption{{\sc Iterative algorithm with complement of backbone estimate}}
\DontPrintSemicolon
\KwIn{Satisfiable formula $F$}
\KwOut{Backbone of $F$, $\nu_r$}
$(outc,\nu_r) \gets SAT(F)$\;
\While{$\nu_r \neq \emptyset$}{
	$bc \gets \bigvee _{l\in\nu_r}\neg l$\;
	$(outc,\nu) \gets SAT(F \cup \{bc\})$\;
	\If{$outc = \bot$}{
		$return\; \nu_r$\;
	}
	$\nu_r \gets \nu_r \cap \nu$\;
}
$\Return \; \nu_r$\;
\end{algorithm}

It generates an upper bound $\nu_r$ of the backbone by intersecting found models and inhibits this upper bound instead of individual models. This blocking clause is much more powerful, because it enforces not only that a new model is found, but also that this new model will reduce the upper bound estimation of the backbone in each iteration. 

This is because what remains after the intersection of a handful of models, are the assignments that were the same in all these models and from that we make a blocking clause that prohibits the next model to contain that particular combination of assignments, eliminating 

Eventually $\nu_r$ will be reduced to the backbone. This can be easily recognized, because the blocking clause of the backbone or any of it's subsets makes the formula unsatisfiable, except in the case that the formulas backbone would be empty. 

Note that it is not particularly important whether the blocking clauses remain in $F$ or get replaced by the next blocking clause, because the new blocking clause $bc_{i+1}$ always subsumes the previous one $bc_i$, meaning that every solution that is prohibited by $bc_{i+1}$ is also prohibited by $bc_i$ and $F \cup \{bc_i , bc_{i+1}\}$ is equivalent to $F \cup \{bc_{i+1}\}$ concerning the set of models.

This algorithm is implemented in the Sat4J library under the designation $IBB$. 

\subsection{Preferences}


\begin{algorithm}
\caption{{\sc BB-pref: Backbone computation using pref-SAT}}
\DontPrintSemicolon
\KwIn{A formula $F$ in CNF}
\KwOut{All literals of the backbone of $F$, $\nu_r$}

$\nu_r \gets SAT(F) $\;
$setPreferences(\{\neg l : l \in \nu_r\})$\;

\InfiniteLoop{}{
	$(\_,\nu) \gets prefSAT(F)$\;
	\If{$\nu \supseteq \nu_r $}{
		$\Return\; \nu_r$\;
	}
	$removePreferences(\{\neg l : l \in \nu_r \textbackslash \nu\})$\;
	$\nu_r \gets \nu_r \cap \nu$\;
}
\end{algorithm}
im unsat fall gibt es kein model, kann also nicht geschnitten werden
drei zeilen im unsat fall erkl채ren
1. zur r체ckgabemenge hinzuf체gen
2. literal nicht mehr pr체fen
3. backbone literal in formel aufnehmen (lernen)


\begin{algorithm}
\caption{{\sc BB-pref: Backbone computation using pref-SAT and blocking clause}}
\DontPrintSemicolon
\KwIn{A formula $F$ in CNF}
\KwOut{All literals of the backbone of $F$, $\nu_r$}

$\nu_r \gets SAT(F)$\;
$setPreferences(\{\neg l : l \in \nu_r\})$\;

\InfiniteLoop{}{
	$bc \gets \bigvee _{l\in\nu_r}\neg l$\;
	$F \gets F \cup \{bc\}$\;

	$(outc,\nu) \gets prefSAT(F)$\;
	\If{$outc = \bot$}{
		$\Return\; \nu_r$\;
	}
	$removePreferences(\{\neg l : l \in \nu_r \textbackslash \nu\})$\;
	$\nu_r \gets \nu_r \cap \nu$\;
}

\end{algorithm}







\section{Iterative algorithms}
\subsection{Testing every literal}
Alternatively, you can define the backbone as all literals that occur with the same assignment in all models of it's problem, which implies that enforcing that variable to it's negation should make the formula unsatisfiable. This definition already leads to a simple algorithm that can calculate the backbone, by checking both assignments of every literal for whether it would make the formula unsatisfiable, see Algorithm 1. This algorithm is referenced in \cite{mjl10}
\begin{algorithm}
\caption{{\sc Iterative algorithm (two tests per variable)}}
\DontPrintSemicolon
\KwIn{A formula $F$ in CNF}
\KwOut{All literals of the backbone of $F$ $\nu_r$}
$\nu_r \gets \emptyset$\;
\For{$x \in Var(F)$}{
	$(outc_1,\nu) \gets SAT(F \cup \{x\})$\;
	$(outc_2,\nu) \gets SAT(F \cup \{\neg x\})$\;
	\If{$outc_1 = \bot \wedge outc_2 = \bot$}{
		$return\; \emptyset$\; 
	}
	\ElseIf{$outc_1 = \bot$}{
		$\nu_r = \nu_r \cup \{\neg x\}$\;
		$F = F \cup \{\neg x\}$\;
	}
	\ElseIf{$outc_2 = \bot$}{
		$\nu_r = \nu_r \cup \{x\}$\;
		$F = F \cup \{x\}$\;
	}
	
}
\Return{$\nu_r$}\;
\end{algorithm}

As is commonly written in literature about boolean satisfiability, the two calls to the $SAT$ function return a pair which consists first of whether the given function was satisfiable at all and, secondly, the found model, which in this case is discarded. There is no good algorithm that can tell whether a boolean formula is satisfiable or not without trying to find a model for said formula, but we can use it to greatly improve the algorithm above by combining this approach with that of the enumeration algorithms.

\subsection{Combining with Enumeration}
First observe that any model of $F$ would already reduce the set of literals to test by half, because for every assignment missing in the model, we know that it cannot be part of the backbone, so there is no need to test it. 

This can be repeated with every further model that we find. The following algorithm is another one that is listed in both \cite{mjl10} and \cite{mjl15} and is implemented in the Sat4J library as $BB$

\begin{algorithm}
\caption{{\sc Iterative algorithm (one test per variable)}}
\DontPrintSemicolon
\KwIn{A formula $F$ in CNF}
\KwOut{All literals of the backbone of $F$ $\nu_r$}

$(outc,\nu) \gets SAT(F)$\;
$\Lambda \gets \nu$\;
$\nu_r \gets \emptyset$\;
\While{$\Lambda \neq \emptyset$}{
	$l \gets pick\; any\; literal\; from\; \Lambda$\;
	$(outc,\nu) \gets SAT(F \cup \{\neg l\})$\;
	\If{$outc = \bot$}{
		$\nu_r \gets \nu_r \cup \{l\}$\;
		$\Lambda \gets \Lambda \textbackslash \{l\} $\;
		$F \gets F \cup \{l\}$\;
	}
	\Else{
		$\Lambda \gets \Lambda \cap \nu$\;
	}
	
}
$\Return \; \nu_r$\;
\end{algorithm}

Note that both possible results of the call to the sat solver are converted to useful information. In the else branch, the formula together with the blocked literal $l$ was still solvable. In this case $\nu$ is still a valid model for $F$, so we can search through it to look for more variables that don't need to be checked. Note that here $\nu$ must contain $\neg l$, as it was enforced.

In the other case, we identified $l$ as a backbone literal. In that case it will be added to the returned set, removed from the set of literals to test and, lastly, added to the problem $F$, which increases performance in subsequent solving steps. However it would be even better, not only to reuse the learned backbone literals, but all learned clauses.




