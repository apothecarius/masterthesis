\section{Cheap Identification of backbone literals}
This section describes various ways that allow you to recognize backbone literals without an additional satisfiability check. Knowing these backbone literals early can speed up the individual calls to the SAT solver, because enforcing the backbone literals prevents the solver from trying to find solutions containing the inverse of the backbone literals, which by definition don't exist.
%Furthermore the latter two subsections here work solely on the set of already identified backbone literals.


\subsection{Axiomatic literals}
The most straightforward method to quickly identify backbone literals is to scan the formula for clauses with only a single literal. Since these clauses have only one possible way to become satisfied, that assignment must be used in every model of the formula and is therefore backbone. It makes sense to do this check after every sat computation, as every different way that leads to a different model brings different learned clauses, that may sometimes consist of a single literal.

However you have to make sure that you don't add learned literals to your returned backbone set if they were already disproven to be part of the backbone which you can tell from your current blocking clause.

TODO beweisen oder rausnehmen.

An expansion on this would be to look for pairs of clauses $(a,b)$, $(a,\neg b)$ for any two variables of the formula. The only way to fulfill this pair of clauses is to assign $a$ to $\top$. This scheme can theoretically be applied to any clause size, but then you would require a quadratically increasing number of clauses to determine a backbone which would first increase computation time and secondly decrease the chance that the necessary set of clauses was available.

Außerdem: alle assignments in CDCL level 0


\subsection{Unit Implication}

yadayada

bedingung: damit c hier angewandt werden kann müssen alle literale darin backbone sein und $n_c - 1$ davon müssen bekannt sein.


We have tested this method in two solvers, $BB$ and a variant of $PrefBones$ that learns backbone literals only from clause learning as described in the previous subsection. This clearly showed that this method requires a critical mass of already known backbone literals to have a benefit, because as already stated, if there even exists a clause in $F$ where this method can be applied, you need to know the $n_c - 1$ other backbone literals in $c$ beforehand.

The learned backbone literals alone can rarely supply this, before the $PrefBones$ algorithm terminates from other conditions. However the iterative approach of the $BB$ solver, testing every yet unidentified literal individually, is much faster at providing positively identified backbone literals that you need to imply other backbone literals through unit implication.

TODO tabelle mit numUnitLits verglichen zwischen pb1e und kbb. Soll auch zwischen vonThore und satComb unterscheiden.

\subsection{Implication through Cohabitation} TODO besserer name

Gegeben den Fall, Literal +a wurde als teil des Backbones identifiziert.\newline
Wenn ein literal +b existiert das in allen Klauseln auftritt die auch +a enthalten, dann ist -b im Backbone\newline
Beweis: Angenommen -b wäre nicht im backbone, dann gäbe es eine lösung die +b enthält\newline
Alle Klauseln die +b enthalten enthalten auch +a, also wäre +a optional\newline
