\section{Cheap Identification of backbone literals}
This section describes various ways that allow you to recognize backbone literals without an additional satisfiability check. Knowing these backbone literals early can speed up the individual calls to the SAT solver, because enforcing the backbone literals prevents the solver from trying to find solutions containing the inverse of the backbone literals, which by definition don't exist.
%Furthermore the latter two subsections here work solely on the set of already identified backbone literals.


\subsection{Axiomatic literals}
The most straightforward method to quickly identify backbone literals is to scan the formula for clauses with only a single literal. Since these clauses have only one possible way to become satisfied, that assignment must be used in every model of the formula and is therefore backbone. It makes sense to do this check after every sat computation, as every different way that leads to a different model brings different learned clauses, that may sometimes consist of a single literal.

However, if you want to use this feature in each iteration, make sure that your learned clauses do not stem from the means in which you enforce different models, for example the blocking clauses in $IBB$ or the checked literal in $BB$. Otherwise, you might confuse the backbone literals of your original problem $F$ with literals that only became axiomatic in your modified formula. \footnote{A simple example: You find an implicant $\{a\}$ with only a single literal. Then you add the blocking clause $\{\neg a\}$. But in $F \cup \{\neg a\}$ $\neg a$ is suddenly a backbone literal.}

The $BB$ solver manages this by having the feature of $assumptions$, which were first proposed in \cite{ENSO03}. These assumptions are assignments that are tested for whether the formula has a model that contains these assignments. For this, the CDCL table is first filled with decisions, that match the assumptions and subsequently the CDCL algorithm runs it's course ordinarily, except that the root decision level is after the entries that assign the assumptions. This has the effect that the assignments from the assumptions can not be taken back through backtracking, instead returning that $F$ is unsatisfiable under the given assumptions.

Once a model was found, all the learned clauses are checked whether they are related to the assumptions, and if so, they must be discarded, as is mentioned in \cite{WKS01}. This way, the assumptions will not have any long term effect
\footnote{\cite{ENSO03} actually states that ``all learned clauses are safe to keep''. \cite{WKS01} differs from \cite{ENSO03} in that here clauses are removed explicitely whereas assumptions are removed automatically.}
. The $IBB$ on the other hand is implemented to discard all learned clauses after every iteration, which gives it a tremendous performance loss.

TODO: IBB und prefbones sind ohne verlernte klauseln immer noch sound. Wieso??

Note that there are cases where you want to keep learned clauses between SAT calls. For example you can pass the solver the set of literals of which you already know that they are part of the backbone to help the solving process. Clauses that are learned from these learned literals in combination with other clauses of the formula will also help in this, so they should also be kept. In this case, for each identified backbone literal $l_b$ augment your formula $F$ to $F \cup \{l_b\}$, which is actually fully equivalent to $F$ in terms of the set of it's models, just more explicit in the fact that $l_b$ is a backbone of it.

An expansion on this would be to look for pairs of clauses $(a,b)$, $(a,\neg b)$ for any two variables of the formula. The only way to fulfill this pair of clauses is to assign $a$ to $\top$. This scheme can theoretically be applied to any clause size, but then you would require a quadratically increasing number of clauses to determine a backbone which would first increase computation time and secondly decrease the chance that the necessary set of clauses was available.

Additionally, you can identify axiomatic literals if you check the table that is generated by CDCL when you search for a model for $F$. If it lists assignments that happened through unit propagation before any decision happened, then you can safely assume that they are axiomatic and part of the backbone, except of course if they were implied by modifications of F.

TODO tabelle mit wieviele literale dabei rausgefunden werden

\subsection{Unit Implication}
\label{subsec:unitImpl}

yadayada

bedingung: damit c hier angewandt werden kann müssen alle literale darin backbone sein und $n_c - 1$ davon müssen bekannt sein.


We have tested this method in two solvers, $BB$ and a variant of $PrefBones$ that learns backbone literals only from clause learning as described in the previous subsection. This clearly showed that this method requires a critical mass of already known backbone literals to have a benefit, because as already stated, if there even exists a clause in $F$ where this method can be applied, you need to know the $n_c - 1$ other backbone literals in $c$ beforehand.

The learned backbone literals alone can rarely supply this, before the $PrefBones$ algorithm terminates from other conditions. However the iterative approach of the $BB$ solver, testing every yet unidentified literal individually, is much faster at providing positively identified backbone literals that you need to imply other backbone literals through unit implication.

TODO tabelle mit numUnitLits verglichen zwischen pb1e und kbb. Soll auch zwischen vonThore und satComb unterscheiden.

\subsection{Implication through Cooccurrence}

Another method to recognize backbone literals from other ones is described in \cite{wbxcl16} and the rationale goes as follows:
%\newtheorem{Printed output}
\begin{lemma}
Given a backbone literal $a$ and another literal $b$. If $b$ occurs in all clauses that also contain $a$, then $\neg b$ must be part of the backbone. 

Proof: Assuming $\neg b$ was not in the backbone, then there would have to exist a model that contained $b$. Given that all clauses that contain $b$ also contain $a$, $a$ cannot be part of the backbone.
\end{lemma}

In other words, if we determine a new backbone literal, and all clauses that contain it, also contain another literal, then we can add the negation of the latter to our backbone set. 

bisschen dazu schreibseln. Diskussion unit case ist ja auch selten

refinedEssentials benchmark hat selten überhaupt irgendwelche damit festgestellt, höchstens 4, bei zwischen 200 und 400 variablen
dimacs-hanoi5 hat 47

tabelle zum vergleich zwischen normalen KBB und KBB mit cooccurrence hinklatschen (je datei, nur implizierte backbone literale)



TODO überlegen, ob es sinnmacht überhaupt zwei variablen zu haben die in denselben klauseln auftauchen
